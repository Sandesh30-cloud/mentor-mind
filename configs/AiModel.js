const {
  GoogleGenerativeAI,
  HarmCategory,
  HarmBlockThreshold,
} = require("@google/generative-ai");

const apiKey = process.env.NEXT_PUBLIC_GEMINI_API_KEY;
const genAI = new GoogleGenerativeAI(apiKey);

const model = genAI.getGenerativeModel({
  model: "gemini-1.5-flash",
});

const generationConfig = {
  temperature: 1,
  topP: 0.95,
  topK: 40,
  maxOutputTokens: 8192,
  responseMimeType: "text/plain",
};

export const courseOutlineAIModel = model.startChat({
  generationConfig,
  history: [
    {
      role: "user",
      parts: [
        {
          text: "Generate a study material for python for exam and level of difficulty will be easy with summery of course, List of Chapters along with summery for each chapter, topic list in each chapter, all result in JSON format.",
        },
      ],
    },
    {
      role: "model",
      parts: [
        {
          text: '```json\n{\n  "courseTitle": "Introduction to Python Programming (Easy)",\n  "courseSummary": "This course provides a beginner-friendly introduction to Python programming.  It covers fundamental concepts and syntax, enabling students to write basic Python programs.  The focus is on understanding core principles rather than advanced techniques.",\n  "chapters": [\n    {\n      "chapterTitle": "Chapter 1: Introduction to Python",\n      "chapterSummary": "This chapter introduces Python, its applications, and setting up the programming environment.  It covers basic syntax and running your first Python program.",\n      "topics": [\n        "What is Python?",\n        "Why use Python?",\n        "Installing Python",\n        "Setting up a development environment (IDE/text editor)",\n        "Running your first Python program",\n        "Basic Syntax: Indentation, Comments"\n      ]\n    },\n    {\n      "chapterTitle": "Chapter 2: Data Types and Variables",\n      "chapterSummary": "This chapter explores fundamental data types in Python, including integers, floats, strings, and booleans, and how to work with variables.",\n      "topics": [\n        "Integers",\n        "Floating-point numbers",\n        "Strings",\n        "Booleans",\n        "Variables and assignment",\n        "Type conversion"\n      ]\n    },\n    {\n      "chapterTitle": "Chapter 3: Operators",\n      "chapterSummary": "This chapter covers various operators in Python, including arithmetic, comparison, logical, and assignment operators.",\n      "topics": [\n        "Arithmetic operators (+, -, *, /, //, %, **)",\n        "Comparison operators (==, !=, >, <, >=, <=)",\n        "Logical operators (and, or, not)",\n        "Assignment operators (=, +=, -=, *=, /=)",\n        "Operator precedence"\n      ]\n    },\n    {\n      "chapterTitle": "Chapter 4: Control Flow (Conditional Statements)",\n      "chapterSummary": "This chapter explains how to control the flow of execution in a program using if, elif, and else statements.",\n      "topics": [\n        "if statement",\n        "if-else statement",\n        "if-elif-else statement",\n        "Nested conditional statements",\n        "Boolean expressions"\n      ]\n    },\n    {\n      "chapterTitle": "Chapter 5: Loops",\n      "chapterSummary": "This chapter introduces for and while loops for iterating over sequences and performing repetitive tasks.",\n      "topics": [\n        "for loop",\n        "while loop",\n        "Loop control statements (break, continue)",\n        "Nested loops",\n        "Iterating through strings and lists"\n      ]\n    },\n    {\n      "chapterTitle": "Chapter 6: Data Structures: Lists and Tuples",\n      "chapterSummary": "This chapter introduces lists and tuples, fundamental data structures for storing collections of items.",\n      "topics": [\n        "Lists: creation, accessing elements, methods (append, insert, remove, etc.)",\n        "Tuples: creation, accessing elements, immutability",\n        "List slicing",\n        "List comprehension (basic introduction)"\n      ]\n    },\n    {\n      "chapterTitle": "Chapter 7: Functions",\n      "chapterSummary": "This chapter explains how to define and use functions to modularize code and improve reusability.",\n      "topics": [\n        "Defining functions",\n        "Function arguments and parameters",\n        "Return values",\n        "Function calls",\n        "Scope of variables"\n      ]\n    },\n    {\n      "chapterTitle": "Chapter 8: Input and Output",\n      "chapterSummary": "This chapter covers how to get input from the user and display output to the console.",\n      "topics": [\n        "Input function (input())",\n        "Print function (print())",\n        "Formatting output using f-strings"\n      ]\n    }\n  ]\n}\n```\n',
        },
      ],
    },
  ],
});

export const generateNotesAiModel = model.startChat({
  generationConfig,
  history: [
    {
      role: "user",
      parts: [
        {
          text: 'Generate exam material detail content for each chapter , Make sure to includes all topic point in the content, make sure to give content in HTML format (Do not Add HTMLKL , Head, Body, title tag), The chapters:\n"chapters": [\n    {\n      "chapterTitle": "Chapter 1: Object-Oriented Programming (OOP) in JavaScript",\n      "chapterSummary": "This chapter explores the principles of OOP in JavaScript, including classes, inheritance, and prototypes, enabling you to structure your code more effectively.",\n      "topics": [\n        "Understanding Prototypes",\n        "Creating Classes with `class` syntax",\n        "Inheritance using `extends`",\n        "Polymorphism and Method Overriding",\n        "Encapsulation and Data Hiding (using closures)",\n        "Working with `this` keyword in different contexts"\n      ]\n    },\n',
        },
      ],
    },
    {
      role: "model",
      parts: [
        {
          text: '```html\n<h2>Chapter 1: Object-Oriented Programming (OOP) in JavaScript</h2>\n<p>This chapter explores the principles of OOP in JavaScript, including classes, inheritance, and prototypes, enabling you to structure your code more effectively.</p>\n\n<h3>Topics:</h3>\n\n<h4>Understanding Prototypes</h4>\n<ul>\n    <li><b>What are Prototypes?</b>\n        <ul>\n            <li>Prototypes are the mechanism by which JavaScript objects inherit features from one another.</li>\n            <li>Every object in JavaScript has a hidden property called `[[Prototype]]`, which can be accessed using `__proto__` (although it\'s recommended to use `Object.getPrototypeOf()` and `Object.setPrototypeOf()`).</li>\n            <li>This `[[Prototype]]` property points to another object, which serves as the prototype for the first object.</li>\n        </ul>\n    </li>\n    <li><b>Prototype Chain</b>\n        <ul>\n            <li>When you try to access a property or method of an object, JavaScript first checks if the object itself has that property.</li>\n            <li>If not, it looks in the object\'s prototype.</li>\n            <li>If not found in the prototype, it checks the prototype\'s prototype, and so on, forming a chain.</li>\n            <li>This chain continues until the prototype is `null`, at which point the property is considered not found.</li>\n        </ul>\n    </li>\n    <li><b>Prototype Methods and Properties</b>\n        <ul>\n            <li>Prototypes can hold both properties (data) and methods (functions).</li>\n            <li>These properties and methods are inherited by all objects that have the prototype as their `[[Prototype]]`.</li>\n            <li>Example: `String.prototype.toUpperCase()` is available to all string instances.</li>\n        </ul>\n    </li>\n    <li><b>Using `Object.create()`</b>\n        <ul>\n            <li>Creates a new object with the specified prototype object.</li>\n            <li>Allows setting the prototype explicitly.</li>\n            <li>Useful for creating object instances with custom prototypes.</li>\n        </ul>\n    </li>\n    <li><b>Benefits of Prototypes</b>\n        <ul>\n            <li>Code Reusability: Avoids redundant code by sharing properties and methods.</li>\n            <li>Memory Efficiency: Only one copy of a method exists, shared across multiple objects.</li>\n            <li>Extensibility: You can extend existing objects by modifying their prototypes.</li>\n        </ul>\n    </li>\n</ul>\n\n<h4>Creating Classes with `class` syntax</h4>\n<ul>\n    <li><b>Introduction to `class`</b>\n        <ul>\n            <li>`class` syntax in JavaScript is syntactic sugar over the prototype-based inheritance model.</li>\n            <li>Provides a cleaner and more familiar way to define object blueprints.</li>\n            <li>Doesn\'t change how inheritance works internally (still relies on prototypes).</li>\n        </ul>\n    </li>\n    <li><b>Defining a Class</b>\n        <ul>\n            <li>Use the `class` keyword followed by the class name.</li>\n            <li>Example: `class Animal { ... }`</li>\n        </ul>\n    </li>\n    <li><b>The `constructor` Method</b>\n        <ul>\n            <li>A special method within a class that is automatically called when a new object (instance) of the class is created using the `new` keyword.</li>\n            <li>Used to initialize the object\'s properties.</li>\n            <li>Example: `constructor(name) { this.name = name; }`</li>\n        </ul>\n    </li>\n    <li><b>Class Methods</b>\n        <ul>\n            <li>Methods are functions defined within the class.</li>\n            <li>They operate on the object\'s properties (data).</li>\n            <li>Defined like regular functions, but inside the class body.</li>\n            <li>Example: `speak() { console.log(\'Generic animal sound\'); }`</li>\n        </ul>\n    </li>\n    <li><b>Class Fields (Properties)</b>\n        <ul>\n            <li>Properties that are part of the object\'s state.</li>\n            <li>Declared and initialized within the `constructor` or directly inside the class.</li>\n            <li>Example: `class Animal { name; constructor(name) { this.name = name; } }`  or `class Animal { name = \'default\'; }`</li>\n        </ul>\n    </li>\n</ul>\n\n<h4>Inheritance using `extends`</h4>\n<ul>\n    <li><b>Introduction to Inheritance</b>\n        <ul>\n            <li>Inheritance allows a class (child class or subclass) to inherit properties and methods from another class (parent class or superclass).</li>\n            <li>Promotes code reusability and organization.</li>\n        </ul>\n    </li>\n    <li><b>The `extends` Keyword</b>\n        <ul>\n            <li>Used to create a subclass that inherits from a superclass.</li>\n            <li>Example: `class Dog extends Animal { ... }`</li>\n        </ul>\n    </li>\n    <li><b>The `super()` Keyword</b>\n        <ul>\n            <li>Used within the subclass\'s constructor to call the constructor of the superclass.</li>\n            <li>Must be called before using `this` in the subclass\'s constructor.</li>\n            <li>Passes arguments to the superclass constructor to initialize inherited properties.</li>\n            <li>Example: `constructor(name, breed) { super(name); this.breed = breed; }`</li>\n        </ul>\n    </li>\n    <li><b>Method Overriding and Accessing Superclass Methods</b>\n        <ul>\n            <li>Subclasses can override methods inherited from the superclass (see Polymorphism).</li>\n            <li>Use `super.methodName()` to call a method of the superclass from within the subclass.</li>\n            <li>Useful for extending or modifying superclass behavior.</li>\n        </ul>\n    </li>\n</ul>\n\n<h4>Polymorphism and Method Overriding</h4>\n<ul>\n    <li><b>Definition of Polymorphism</b>\n        <ul>\n            <li>The ability of objects of different classes to respond to the same method call in their own way.</li>\n            <li>"Many forms".</li>\n            <li>Makes code flexible and adaptable.</li>\n        </ul>\n    </li>\n    <li><b>Method Overriding</b>\n        <ul>\n            <li>When a subclass provides a specific implementation of a method that is already defined in its superclass.</li>\n            <li>The subclass\'s method "overrides" the superclass\'s method for instances of the subclass.</li>\n        </ul>\n    </li>\n    <li><b>Example of Method Overriding</b>\n        <ul>\n            <li>A `Dog` class extending `Animal` can override the `speak()` method to output "Woof!" instead of the generic "Generic animal sound".</li>\n        </ul>\n    </li>\n    <li><b>Benefits of Polymorphism</b>\n        <ul>\n            <li>Code Flexibility: Enables writing code that can work with objects of different classes without knowing their specific type.</li>\n            <li>Code Reusability:  Common behavior can be defined in superclasses and specialized in subclasses.</li>\n            <li>Maintainability: Easy to add new classes without modifying existing code.</li>\n        </ul>\n    </li>\n</ul>\n\n<h4>Encapsulation and Data Hiding (using closures)</h4>\n<ul>\n    <li><b>Encapsulation Definition</b>\n        <ul>\n            <li>Bundling data (properties) and methods that operate on that data within a single unit (a class or object).</li>\n            <li>Protecting the internal state of an object from direct access or modification from the outside.</li>\n        </ul>\n    </li>\n    <li><b>Data Hiding / Information Hiding</b>\n        <ul>\n            <li>Restricting access to the internal data (properties) of an object.</li>\n            <li>Making certain properties private or protected to prevent unintended modifications.</li>\n            <li>Increases code maintainability and reduces the risk of bugs.</li>\n        </ul>\n    </li>\n    <li><b>Implementing Encapsulation and Data Hiding in JavaScript (Pre-ES6 and ES6+)</b>\n        <ul>\n            <li><b>Pre-ES6 using Closures:</b>  Closures are used to create private variables and methods.</li>\n                <ul>\n                  <li>A function that "remembers" the variables around it, even after the outer function has finished executing.</li>\n                  <li>Properties defined within a closure are only accessible from inside the closure (effectively private).</li>\n                </ul>\n                <li><b>Example</b>\n                  <pre><code>\n                    function createCounter() {\n                        let count = 0; // Private variable\n                        return {\n                            increment: function() { count++; },\n                            getCount: function() { return count; }\n                        };\n                    }\n\n                    const counter = createCounter();\n                    counter.increment();\n                    console.log(counter.getCount()); // Output: 1\n                    // console.log(count); // Error: count is not defined (private)\n                  </code></pre>\n\n            </li>\n            <li><b>ES6+ using Private Class Fields (Proposed and Limited Browser Support)</b>\n              <ul>\n                <li>Currently, there isn\'t a native built-in mechanism for truly private properties in JavaScript as robust as in languages like Java or C++.  However, there is a proposal for Private Class Fields.</li>\n                <li>Properties and methods marked with a \'#\' prefix are considered private within the class. They can only be accessed from within the class.</li>\n                </ul>\n                </li>\n                <li><b>Example</b>\n                <pre><code>\n                    class Counter {\n                      #count = 0; // Private field\n\n                      increment() {\n                        this.#count++;\n                      }\n\n                      getCount() {\n                        return this.#count;\n                      }\n                    }\n\n                    const counter = new Counter();\n                    counter.increment();\n                    console.log(counter.getCount()); // Output: 1\n                    // console.log(counter.#count); // Error: Private field \'#count\' must be declared in an enclosing class\n                </code></pre>\n\n            </li>\n        </ul>\n    </li>\n    <li><b>Getters and Setters</b>\n        <ul>\n            <li>Methods used to control access to properties.</li>\n            <li>Getters: Used to read the value of a property (like a `getter` in other languages).</li>\n            <li>Setters: Used to write/modify the value of a property (like a `setter` in other languages).</li>\n            <li>Provide a way to add logic before getting or setting a property\'s value.</li>\n            <li>Example:</li>\n            <pre><code>\n                class Person {\n                    constructor(firstName, lastName) {\n                        this._firstName = firstName;  // Convention: Use _ to indicate "protected-like" properties\n                        this._lastName = lastName;\n                    }\n\n                    get fullName() {\n                        return `${this._firstName} ${this._lastName}`;\n                    }\n\n                    set fullName(name) {\n                        const [first, last] = name.split(" ");\n                        this._firstName = first;\n                        this._lastName = last;\n                    }\n                }\n\n                const person = new Person("John", "Doe");\n                console.log(person.fullName); // Output: John Doe\n                person.fullName = "Jane Smith";\n                console.log(person.fullName); // Output: Jane Smith\n            </code></pre>\n        </ul>\n    </li>\n</ul>\n\n<h4>Working with `this` keyword in different contexts</h4>\n<ul>\n    <li><b>`this` in Global Context</b>\n        <ul>\n            <li>In the global scope (outside of any function), `this` refers to the global object (e.g., `window` in browsers, `global` in Node.js).</li>\n            <li>In strict mode, `this` is `undefined` in the global context.</li>\n        </ul>\n    </li>\n    <li><b>`this` in a Method</b>\n        <ul>\n            <li>When a function is called as a method of an object (e.g., `obj.method()`), `this` refers to the object that the method is called on (`obj` in this example).</li>\n        </ul>\n    </li>\n    <li><b>`this` in a Function (without being a method)</b>\n        <ul>\n            <li>If a function is called independently (not as a method), the value of `this` depends on the context.</li>\n            <li>In strict mode, `this` will be `undefined`.</li>\n            <li>In non-strict mode, `this` will be the global object.</li>\n        </ul>\n    </li>\n    <li><b>`this` with Constructor Functions and Classes</b>\n        <ul>\n            <li>When a function is called with the `new` keyword (a constructor function), `this` refers to the newly created object (the instance).</li>\n            <li>In classes, `this` works similarly to constructors, referring to the instance of the class.</li>\n        </ul>\n    </li>\n    <li><b>`this` with Arrow Functions</b>\n        <ul>\n            <li>Arrow functions do not have their own `this` binding.  They lexically bind `this` from the surrounding context (where the arrow function is defined).</li>\n            <li>`this` inside an arrow function will refer to the `this` of the enclosing function or scope.</li>\n        </ul>\n    </li>\n    <li><b>Explicit Binding with `call`, `apply`, and `bind`</b>\n        <ul>\n            <li>These methods allow you to explicitly set the value of `this` when calling a function.</li>\n            <li>`call()`: Calls a function, setting `this` to the first argument and passing the remaining arguments individually.</li>\n            <li>`apply()`: Calls a function, setting `this` to the first argument and passing the remaining arguments as an array.</li>\n            <li>`bind()`: Creates a new function with `this` bound to a specific value. Does not immediately execute the function.</li>\n            <li>Example:</li>\n            <pre><code>\n                const obj = { name: "Example" };\n                function greet() {\n                    console.log(`Hello, my name is ${this.name}`);\n                }\n\n                greet.call(obj);     // Output: Hello, my name is Example (using call)\n                greet.apply(obj);    // Output: Hello, my name is Example (using apply)\n                const boundGreet = greet.bind(obj);\n                boundGreet();        // Output: Hello, my name is Example (using bind)\n            </code></pre>\n        </ul>\n    </li>\n    <li><b>Common `this` Pitfalls and Best Practices</b>\n        <ul>\n            <li>Be mindful of how `this` is bound in different contexts.</li>\n            <li>Use arrow functions to avoid `this` binding issues when working with callbacks or event handlers (when you want `this` to refer to the enclosing scope).</li>\n            <li>Use `call`, `apply`, or `bind` when you need to explicitly control the value of `this`.</li>\n        </ul>\n    </li>\n</ul>\n```\n',
        },
      ],
    },
  ],
});

// Define an async function to send messages
export async function sendCourseOutlineMessage(userInput) {
  const result = await courseOutlineAIModel.sendMessage(userInput);
  return result.response.text();
}

// Example usage
async function run() {
  try {
    const response = await sendCourseOutlineMessage(
      "Tell me more about Python functions"
    );
    console.log(response);
  } catch (error) {
    console.error("Error:", error);
  }
}

export const GenerateStudyTypeContentAiModel = model.startChat({
  generationConfig,
  history:[
    {
      role: "user",
      parts:[
        { text: 'Generate Quiz on topic: Flutter fundamentals, User Interface(UI) Development, Basic app navigation with Question and Options along with correct answer in JSON format, (Max 10)' },
      ]
    },
    {
      role: 'model',
      parts: [
        { text: '```json\n[\n  {\n    "question": "What is Flutter?",\n    "options": [\n      "A database management system",\n      "A UI toolkit for building cross-platform applications",\n      "A programming language",\n      "A web browser"\n    ],\n    "correctAnswer": "A UI toolkit for building cross-platform applications"\n  },\n  {\n    "question": "Which programming language is used in Flutter?",\n    "options": [\n      "Java",\n      "Python",\n      "Dart",\n      "JavaScript"\n    ],\n    "correctAnswer": "Dart"\n  },\n  {\n    "question": "What is a Widget in Flutter?",\n    "options": [\n      "A database table",\n      "A basic building block of the UI",\n      "A type of animation",\n      "A color scheme"\n    ],\n    "correctAnswer": "A basic building block of the UI"\n  },\n  {\n    "question": "What is the difference between StatelessWidget and StatefulWidget?",\n    "options": [\n      "StatelessWidget is faster than StatefulWidget",\n      "StatelessWidget cannot have child widgets",\n      "StatefulWidget can update its state during runtime",\n      "StatefulWidget is used only for animations"\n    ],\n    "correctAnswer": "StatefulWidget can update its state during runtime"\n  },\n  {\n    "question": "How do you navigate to a new screen in Flutter?",\n    "options": [\n      "Using Navigator.push()",\n      "Using Screen.change()",\n      "Using Route.next()",\n      "Using Page.forward()"\n    ],\n    "correctAnswer": "Using Navigator.push()"\n  }\n]\n```' },
      ],
    },
    {
      role: 'user',
      parts: [
        { text: 'INSERT_INPUT_HERE' },
      ],
    },
  ]
});

// Call the run function
run();
